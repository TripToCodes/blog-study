# 💡 비전공자에게 내새끼(나의 코딩) 설명하기 시리즈 1️⃣ — 댓글과 답글

## - 댓글과 대댓글 뒤에 숨어있는 피, 땀, 눈물(feat. BTS)

### 1. 댓글의 기본 구성

<img width="244" alt="commentSchema" src="https://user-images.githubusercontent.com/79065544/174426748-f2b0d0f8-0831-4235-b8e9-b750452f9ff3.png">

- `id`: 각각의 댓글은 모두 데이터베이스 안에서 고유한 아이디를 가지지. 사용자의 고유한 아이디만 있다면 그 사람의 모든 댓글까지 굳이 아이디가 있어야 할까? 라고 생각할 수도 있어. 하지만 모든 댓글의 아이디가 고유하지 않고 중복되는 아이디가 있거나 하면 특정 댓글의 수정이나 삭제를 눌렀을 때 엄한 댓글이 삭제될 수도 있잖아? 그래서 모든 댓글은 아이덴티티가 필요해.
- `userId`: 어떤 사용자가 쓴 댓글인지 당연히 알 수 있어야 겠지. 보통 사용자의 닉네임이나 프로필 사진, 개인 정보 등을 모아놓은 데이터베이스가 있기 마련이고 우리는 그 정보를 끌어 와서 댓글의 고유한 아이디와 짝지어 놓는 거야.
- `postId`: 댓글만 덩그러니 있는 경우는 없지? 보통 사진이나 글의 포스팅 아래 달리니까 이 댓글이 어떤 포스팅에 달린 것인지 그 포스팅의 고유한 아이디도 알아야 하지.
- `content`: 이게 우리가 생각하는 댓글의 내용이지.
- `createdAt`, `updatedAt`: 댓글이 언제 달렸고 언제 수정되었는지 알 수 있어야겠지?

### 2. 대댓글을 가능하게 해주는 마법

- `parentId`: 대댓글이 아닌 일반 댓글은 `parentId`가 `null`(없음)이야. 그런데 만약 대댓글이 달린다면? 이 대댓글은 댓글처럼 고유한 아이디를 가짐과 동시에 parentId라는게 주어지지. 한 마디로 대댓글은 자식이고 대댓글을 주렁주렁 달고 있는 댓글은 부모님이라는 거야. 부모님의 고유한 아이디를 대댓글이 품고 있는 거지. 등본 떼면 부모님 이름이 나오는 것처럼!
  
### 3. 수정과 삭제는 아무나 하나

- `user.id === comment.userId`: 내가 쓴 댓글에만 수정과 삭제 버튼이 보여야겠지? 관리자도 아닌데 다른 사람 댓글도 내키는 대로 삭제할 수 있다면 댓글이 난리가 나겠지. 그래서 댓글이 가지고 있는 유저의 정보가 현재 브라우저를 지켜보고 있는 유저와 같은 사람인지 판별하고 그에 따라 볼 수 있는 버튼이 달라져야 해. 스크린샷을 보면 내가 쓰지 않은 댓글에는 답글 버튼만 있고 내가 작성한 댓글에는 답글, 수정, 삭제 3가지가 보이지? 수정 버튼을 누르면 또 수정과 취소라는 버튼이 새로 생기지. 사용자가 도대체 뭘 하려고 하는 지 집요하게 따라붙어 정확한 버튼을 보여줘야 하는 고독한 싸움이야.

### 4. 댓글 작성 활성 상태

- `activeComment` or not?: 댓글을 작성하는 분홍색 입력창이 댓글이나 수정 버튼을 누르는 곳마다 열리고 댓글 작성이 완료된 후에도 열려있다고 생각해 봐. 몇 번 클릭하다 보면 결국엔 분홍색 네모가 너무 많아져서 보기 좋지 않을 거야. 그래서 활성 입력창은 한번에 하나만 열리게 해뒀어. 첫 번째 댓글에 답글 버튼을 눌렀다가 다른 댓글에 답글을 달기로 마음을 바꾸면 위의 활성창은 닫히고 아래에 새로 열리는 거야. 댓글 작성이 완료되면 당연히 분홍 활성창이 없어지고 새로운 댓글만 보여주고 말야.

### 5. 재깍재깍 업데이트

- 새로운 정보가 입력, 수정, 삭제되면 그걸 백엔드라 불리는 미지의 세계 데이터베이스로 넘겨줌과 동시에 브라우저에 새 정보가 업데이트가 되어야 하지. 우리는 모르지만 GET/PATCH/DELETE라는 요청과 응답이 끊임없이 오가야만 화면이 업데이트 되는 거야. 데이터를 받아오는 동안 당신의 기다림을 덜 지루하게 할 로딩 애니메이션도 띄워주고... 참 친절하다 친절해!  


> 다음 이야기
무언가를 수정하거나 삭제할 때 일일이 뜨는 확인창을 만드는 것에도 당신의 생각보다 복잡한 미학이 숨어있다는 사실!


> 특정 유저가 게시글을 남길 때 혹은 게시글에 대한 댓글을 남길 때 서버에서는 유저의 어떠한 정보들을 수집할 수 있을까요?
> 예를 들어, 어떤 싸이트에서는 게시글 혹은 댓글을 작성한 사람의 IP가 자동으로 노출되게끔 되어있고, 또 어떤 싸이트는 IP가 공개가 안되는데요. 이를 통해서 추정해볼 때, 기본적으로 유저가 댓글을 남길 때 IP정보가 어떠한 형태로든 서버측에 제공이 됨을 알 수 있습니다. 또한 이는 유저 사이드에서는 별도로 설정을 하지 않았음에도 강제적으로 진행이 되더라구요.


그리고 IP 외에 서버는 특정 유저의 어떠한 정보들을 합법적(!)으로 수집할 수 있을까요? 그저 단순하게 예를 들어 생각하면, 서버에 접속할 때 서버 단에서 유저의 크롬 브라우저 상에 등록되어있는 즐겨찾기 목록을 요청해서 받는다거나, 현재 시스템에 물려있는 하드웨어 목록을 받는 다거나, 혹은 OS에 설치되어 있는 프로그램의 리스트를 추출하는 것도 가능할 것 같다는 생각이 듭니다. 물론 클라이언트 측에서는 기본적으로 방화벽이나 접근 권한을 통해 제한을 하겠지만요. 생각해보면 이것이 순수하게 클라이언트만의 보안 의식 문제로 치부하기에는 리스크가 너무 많지 않나 하는 생각이 들어서요.

위의 생각을 조금 더 확장해보면, 누군가에 의해 악의적으로 댓글 작성을 통한 해킹 시도도 가능하리라 생각이 됩니다. 댓글 작성을 하고 나서 확인 창이 뜨는 경우, 그 확인 버튼에 숨겨진 코드를 링크하고, 확인 버튼(이라 쓰고 권한 제공 동의 버튼이라 읽음..)을 누르는 순간, 권한을 탈취하고 정보를 빼갈 수도 있지 않을까 싶습니다. 물론, 이것은 그저 초보적인 생각이라 브라우저 측에서 감지하고 사전에 차단을 할 수도 있을 것 같기도 합니다.


사실 저희 프로젝트에서는 딱히 IP 주소를 DB에 저장해놓고 그걸 사용자를 식별하거나 하는데 사용하지는 않아서 깊게 생각해보진 않았는데 검색해보니 말씀하신 것처럼 서버로 보내는 모든 요청은 사용자의 동의 여부와 상관없이 IP 주소를 포함하고 있는 것 같아요. 그런데 IP 주소라는게 공용 주소도 있고 아주 민감한 정보 같지는 않아서 크게 걱정은 안 했는데 악용하려는 마음을 먹으면 또 어떻게 쓰일 지 알 길이 없으니... 걱정하시는 마음도 이해가 갑니다.

저희는 JSON Web Token을 이용해 사용자가 회원가입을 할 때 입력한 유저네임, 이메일, 비밀번호를 수집했고 유저네임, 이메일, 비밀번호로 생성한 토큰을 쿠키에 실어 보내는데 사실 이 경우 XSS 공격을 통해 페이지 사용자의 정보를 획득해 정상 사용자인척 할 위험이 있기는 합니다. ㅠㅠ 그래서 저희는 bcrypt라는 라이브러리로 비밀번호를 암호화해서 토큰을 생성하기는 합니다.

검색해보니 IP Address bound JWT라는 것도 있어서 사용자의 IP주소와 토큰을 연결해 놓기도 하더라고요. ([레퍼런스](https://medium.com/@adarsh.pradyut/ip-bound-jwt-6e2669d15391)) 그러면 확실히 불명확한 해외의 어느 IP 주소로 로그인해서 사용자의 정보를 탈취할 수는 없겠지만 모바일로 서비스를 이용하는 경우 WiFi나 데이터로 접속할때마다 IP 주소가 바뀌게 되니 하나의 주소만 연결해 놓으면 나중에 로그인이 안 되는 문제가 발생할 수도 있어서 도입이 정말 필요한 지 따져봐야 할 것 같습니다.

포스팅이나 댓글에 악성 코드를 추가해서 DB에 저장하게끔 하고 그것이 브라우저에 보여지는 경우는 왕왕 있어서 코드를 짤 때 웬만하면 innderHTML 대신에 textContent를 사용하라고 배웠어요. 그러면 이상한 스크립트들이 그냥 string으로 파싱되거든요. 그것말고도 HTTP 대신 HTTPS를 사용한다던가 CSP를 사용한다던가 많은 방법이 있더라고요. 질문해주신 덕분에 안전한 웹서비스 제공을 위해 더 공부해봐야겠다는 의지가 생겼습니다!


---

activeComment는 Bool 타입은 아니고 초기 상태는 null 이고 나중에 객체타입의 인자를 전달합니다. 보성님의 말씀처럼 브라우저 client side js에 있어요!

1. 리덕스 툴킷 슬라이스에 사용자 정보가 있고 parentId가 없는 경우에만 답글을 달 수 있다고 정해 놓았어요. 
2. `onClick`에 `setActiveComment`로 상태를 업데이트 합니다. 
3. 이제  `activeComment`가 더이상 null 이 아니니 `isReplying` 조건도 충족이 된다면 댓글을 `submit`할 수 있어요.
4. 그리고 `addComment`가 실행되면 그 안에 다시 `setActiveComment(null)` 가 호출되어 분홍 활성창이 없어지게 됩니다.

```js
const { user } = useSelector((state) => state.user);

const [activeComment, setActiveComment] = useState(null);

const canReply = Boolean(user?.id) && !comment.parentId;

{canReply && ( 
  <CommentAction
    type="button"
    onClick={() => setActiveComment({ id: comment.id, type: "replying" })}
>답글
</CommentAction>
)}

const isReplying =
  activeComment && activeComment.id === comment.id && activeComment.type === "replying";

{isReplying && (
  <CommentForm
    commentId={comment.id}
    studyId={comment.study_id}
    replyId={replyId}
    submitLabel="작성"
    handleSubmit={addComment}
  />
)}

const addComment = async (commentData) => {
  await dispatch(writeComment(commentData));
  setActiveComment(null);
};

```

